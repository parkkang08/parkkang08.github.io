<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>집중력 분석 웹</title>

  <!-- 그대로 유지 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://unpkg.com/muicss@0.10.3/dist/css/mui.min.css" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5/dist/js/bootstrap.bundle.min.js"></script>
  <script defer src="https://unpkg.com/muicss@0.10.3/dist/js/mui.min.js"></script>
  <script defer src="{{ url_for('static', filename='script.js') }}"></script>

  <style>
    :root{
      --radius-xxl: 1.4rem;
      --ring: 0 0 0 .35rem rgba(99,102,241,.18);
      --success:#16a34a; --success-bg:#dcfce7;
      --danger:#ef4444;  --danger-bg:#ffe4e6;
      --indigo:#6366f1; --pink:#f472b6;
      --muted:#6b7280;
    }
    body{
      background:
        radial-gradient(900px 500px at 0% -10%, #eef2ff, transparent),
        radial-gradient(900px 500px at 120% 10%, #fff1f5, transparent),
        linear-gradient(180deg,#fbfdff,#f7f8fc);
      color:#1f2430;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    .card.glass{
      background:rgba(255,255,255,.78);
      backdrop-filter:saturate(120%) blur(10px);
      border:1px solid rgba(99,102,241,.10);
      border-radius:var(--radius-xxl);
      box-shadow:0 18px 40px rgba(17,24,39,.12);
    }
    .rounded-xxl{border-radius:var(--radius-xxl)!important}
    .btn:focus-visible{box-shadow:var(--ring)}
    video{background:#000; box-shadow:0 14px 36px rgba(0,0,0,.25)}

    #maxScore{font-weight:800; color:#475569}
    #score{
      font-weight:800; font-size:1.05rem;
      padding:.55rem 1rem; border-radius:999px; display:inline-block;
      box-shadow:0 6px 18px rgba(0,0,0,.08);
    }
    .focus{ background:var(--success-bg); color:var(--success) }
    .distract{ background:var(--danger-bg); color:var(--danger) }

    .pill{display:inline-flex;align-items:center;gap:.5rem;padding:.55rem .9rem;border-radius:999px;font-weight:800}
    .mode-idle{background:#eef2f7;color:#49566a}
    .mode-study{background:#e9fbf0;color:#0f9b4f}
    .mode-break{background:#eef2ff;color:#3943d8}

    #banner{
      position:fixed; left:50%; top:14px; transform:translateX(-50%);
      z-index:9999; display:none; padding:.7rem 1rem;
      border-radius:999px; font-weight:900;
      box-shadow:0 14px 40px rgba(0,0,0,.18); border:1px solid rgba(99,102,241,.15);
      background:#fff;
    }
    #banner.ok{ background:var(--success-bg); color:var(--success) }
    #banner.info{ background:#eef2ff; color:#3943d8 }

    .title-gradient{
      background:linear-gradient(90deg,var(--indigo),var(--pink));
      -webkit-background-clip:text; background-clip:text; color:transparent;
    }

    /* 시간 설정 레이아웃 */
    .time-stack{
      display:grid;
      grid-template-columns: 1fr auto;
      column-gap:12px; row-gap:10px; align-items:center;
    }
    .time-row{ display:flex; align-items:center; gap:10px; justify-content:center; }
    .time-row .label{ color:var(--muted); font-weight:700; min-width:52px; text-align:right }
    .unit{ color:var(--muted); font-weight:600 }
    .pill-input{
      width:90px; text-align:center; font-weight:800; color:#111827;
      background:#fff; border:1px solid #e5e7eb; border-radius:999px; padding:8px 12px;
      box-shadow:inset 0 1px 2px rgba(0,0,0,.035), 0 2px 8px rgba(0,0,0,.04);
    }
    .pill-input:focus{ outline:none; box-shadow:0 0 0 .25rem rgba(99,102,241,.15) }
    .apply-btn{
      grid-row:1 / span 2; grid-column:2;
      align-self:stretch; display:flex; align-items:center; justify-content:center;
      border-radius:999px;
    }
    @media (max-width:576px){
      .time-stack{ grid-template-columns:1fr }
      .apply-btn{ grid-row:auto; grid-column:1; width:100%; margin-top:6px }
      .time-row{ flex-wrap:wrap }
    }

    /* 아이콘 ::before */
    button[data-icon]::before{
      content: attr(data-icon);
      display:inline-block;
      margin-right:.45rem;
      transform: translateY(-.5px);
      font-weight:700;
    }
    button:disabled[data-icon]::before{ opacity:.7 }

    /* ⏱ 남은 시간 원형 게이지 */
    .gauge-wrap{ display:flex; justify-content:center; margin:8px 0 14px }
    .gauge{ position:relative; width:120px; height:120px; filter:drop-shadow(0 10px 20px rgba(17,24,39,.12)) }
    .gauge svg{ width:100%; height:100%; transform:rotate(-90deg) }
    .gauge .track{ stroke:rgba(148,163,184,.25); stroke-width:12; fill:none }
    .gauge .bar{ stroke-linecap:round; stroke-width:12; fill:none; transition:stroke-dashoffset .6s linear, stroke .2s ease }
    .gauge .label{ position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; font-weight:900 }
    .gauge .label .time{ font-size:1.1rem; color:#0f172a }
    .gauge .label .sub{ font-size:.78rem; color:#64748b; font-weight:800 }
  </style>
</head>
<body>
  <div id="banner" class="ok">✔ 저장되었습니다</div>

  <div class="container py-4">
    <header class="mb-3 text-center">
      <h1 class="fw-black display-6 title-gradient mb-0">🎯 집중력 분석 웹</h1>
      <div id="maxScore" class="mt-2 small">최고 집중도: 0%</div>
    </header>

    <div class="row g-4 align-items-start">
      <!-- 좌: 미디어 -->
      <section class="col-lg-7">
        <div class="card glass p-3 p-sm-4">
          <div class="text-center">
            <!-- autoplay 안정화 -->
            <video id="video" class="img-fluid rounded-xxl" width="640" height="480"
                   autoplay muted playsinline webkit-playsinline></video>
          </div>
          <div class="text-center mt-3">
            <span id="score" class="distract">분석 대기중…</span>
          </div>
        </div>
      </section>

      <!-- 우: 제어 패널 -->
      <aside class="col-lg-5">
        <div class="card glass p-3 p-sm-4">
          <div class="d-flex flex-wrap gap-2 justify-content-center mb-3">
            <button id="startBtn" class="mui-btn mui-btn--primary btn btn-primary fw-semibold px-3" data-icon="▶">실시간 시작</button>
            <button id="stopBtn" class="mui-btn btn btn-danger fw-semibold px-3" data-icon="⏹" disabled>정지</button>
            <button id="previewBtn" class="mui-btn btn btn-outline-primary fw-semibold px-3" data-icon="👁">미리보기 끄기</button>
            <button id="alarmToggleBtn" class="mui-btn btn btn-outline-secondary fw-semibold px-3" data-icon="🔔">알람 끄기</button>
            <button id="vibrationToggleBtn" class="mui-btn btn btn-outline-secondary fw-semibold px-3" data-icon="📳">진동 끄기</button>
            <button id="flipBtn" class="mui-btn btn btn-outline-dark fw-semibold px-3" data-icon="↔">좌우 반전</button>
          </div>

          <div class="mui-panel rounded-xxl p-3 mb-3">
            <div class="time-stack">
              <div class="time-row">
                <span class="label">공부</span>
                <input type="number" id="studyMin" min="0" value="25" class="pill-input" />
                <span class="unit">분</span>
                <input type="number" id="studySec" min="0" max="59" value="0" class="pill-input" />
                <span class="unit">초</span>
              </div>

              <button id="applyTimeBtn" class="mui-btn btn btn-light border fw-semibold apply-btn" data-icon="⏱">시간 적용</button>

              <div class="time-row">
                <span class="label">휴식</span>
                <input type="number" id="breakMin" min="0" value="5" class="pill-input" />
                <span class="unit">분</span>
                <input type="number" id="breakSec" min="0" max="59" value="0" class="pill-input" />
                <span class="unit">초</span>
              </div>
            </div>
          </div>

          <!-- 상태 -->
          <div class="d-flex flex-wrap gap-2 justify-content-center mb-2">
            <span id="modeText" class="pill mode-idle">모드: -</span>
            <span id="countdown" class="pill" style="background:#fff4e6;color:#b45309">남은 시간: 00:00</span>
            <span id="elapsed" class="pill" style="background:#f3f4f6;color:#111827">경과 시간: 00:00:00</span>
          </div>

          <!-- ⏱ 남은 시간 원형 게이지 -->
          <div class="gauge-wrap">
            <div id="timeGauge" class="gauge" aria-label="남은 시간 게이지">
              <svg viewBox="0 0 120 120" role="img">
                <defs>
                  <linearGradient id="gaugeGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%"  stop-color="#6366f1"/>
                    <stop offset="100%" stop-color="#f472b6"/>
                  </linearGradient>
                </defs>
                <circle class="track" cx="60" cy="60" r="50"></circle>
                <circle class="bar"   cx="60" cy="60" r="50" stroke="url(#gaugeGrad)"></circle>
              </svg>
              <div class="label">
                <div id="gaugeTime" class="time">00:00</div>
                <div class="sub">남은 시간</div>
              </div>
            </div>
          </div>

          <p id="stateText" class="text-secondary small mb-0 text-center">현재 상태: -</p>
        </div>
      </aside>
    </div>
  </div>

  <!-- 알림음 -->
  <audio id="startSound" preload="auto">
    <source src="{{ url_for('static', filename='start.mp3') }}" type="audio/mpeg">
  </audio>
  <audio id="endSound" preload="auto">
    <source src="{{ url_for('static', filename='end.mp3') }}" type="audio/mpeg">
  </audio>

  <!-- MediaPipe Holistic -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5/holistic.min.js"></script>

  <!-- ===== 공통 유틸 + 버튼 브릿지 + 카메라 ===== -->
  <script>
  (function(){
    const ICON_MAP = {startBtn:'▶', stopBtn:'⏹', previewBtn:'👁', alarmToggleBtn:'🔔', vibrationToggleBtn:'📳', flipBtn:'↔', applyTimeBtn:'⏱'};
    const stripEmoji = s => (s||'').replace(/^[\p{Extended_Pictographic}\uFE0F\u200D]+\s*/u,'').trim();
    function ensureIcon(btn, icon){
      if(!btn) return; if(btn.getAttribute('data-icon')!==icon) btn.setAttribute('data-icon',icon);
      const raw=btn.textContent, t=stripEmoji(raw); if(raw!==t) btn.textContent=t;
    }
    function repairIcons(){ for(const [id,ic] of Object.entries(ICON_MAP)) ensureIcon(document.getElementById(id), ic); }
    document.addEventListener('DOMContentLoaded', repairIcons); setInterval(repairIcons, 150);

    function callOne(names, ...args){
      for(const n of names){ const f=typeof window[n]==='function' && window[n]; if(f){ try{ f(...args); return n; }catch(e){ console.error(e); } } }
      if(window.app){
        for(const n of names){
          const key = n.replace(/^(startRealtime|startRealTime|startAnalysis)$/,'start')
                       .replace(/^(stopRealtime|stopAnalysis)$/,'stop')
                       .replace(/^togglePreview$/,'togglePreview')
                       .replace(/^toggleAlarm$/,'toggleAlarm')
                       .replace(/^toggleVibration$/,'toggleVibration')
                       .replace(/^(applyTime|setTimer|updateTime)$/,'applyTime');
          const f = typeof window.app[key]==='function' && window.app[key];
          if(f){ try{ f(...args); return 'app.'+key; }catch(e){ console.error(e); } }
        }
      }
      return null;
    }
    function emit(name, detail){ window.dispatchEvent(new CustomEvent(name,{detail})); document.dispatchEvent(new CustomEvent(name,{detail})); }

    const videoEl = document.getElementById('video');
    async function startCamera(){
      try{
        if(videoEl.srcObject) return;
        const s = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
        videoEl.srcObject = s; videoEl.muted = true; await videoEl.play().catch(()=>{});
      }catch(e){ console.warn('카메라 접근 실패:', e); }
    }
    window.addEventListener('load', startCamera);
    document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && !videoEl.srcObject) startCamera(); });

    const previewBtn = document.getElementById('previewBtn');
    function applyPreviewVisibility(){ const on=(previewBtn.dataset.state!=='off'); videoEl.style.visibility = on ? 'visible' : 'hidden'; }
    previewBtn.addEventListener('click', ()=>{
      const used = callOne(['togglePreview','previewToggle','setPreview','switchPreview']);
      previewBtn.dataset.state = (previewBtn.dataset.state==='off')?'on':'off';
      previewBtn.textContent = (previewBtn.dataset.state==='on')?'미리보기 끄기':'미리보기 켜기';
      repairIcons(); if(!used) applyPreviewVisibility(); emit('app:previewToggle',{used,state:previewBtn.dataset.state});
    });
    previewBtn.dataset.state='on'; applyPreviewVisibility();

    const flipBtn = document.getElementById('flipBtn'); let flipped=false;
    flipBtn.addEventListener('click', ()=>{
      flipped=!flipped; videoEl.style.transform = flipped?'scaleX(-1)':'scaleX(1)';
      flipBtn.textContent = flipped?'반전 해제':'좌우 반전'; repairIcons(); emit('app:flip',{flipped});
    });

    function toggleLabel(btn, onLabel, offLabel){ const on=(btn.dataset.state!=='off'); btn.dataset.state=on?'off':'on'; btn.textContent=(btn.dataset.state==='on')?onLabel:offLabel; repairIcons(); }
    const alarmToggleBtn = document.getElementById('alarmToggleBtn');
    const vibrationToggleBtn = document.getElementById('vibrationToggleBtn');
    alarmToggleBtn.addEventListener('click', ()=>{ const used=callOne(['toggleAlarm','alarmToggle','setAlarm']); toggleLabel(alarmToggleBtn,'알람 끄기','알람 켜기'); emit('app:alarmToggle',{used,state:alarmToggleBtn.dataset.state}); });
    vibrationToggleBtn.addEventListener('click', ()=>{ const used=callOne(['toggleVibration','vibrationToggle','setVibration']); toggleLabel(vibrationToggleBtn,'진동 끄기','진동 켜기'); emit('app:vibrationToggle',{used,state:vibrationToggleBtn.dataset.state}); });
  })();
  </script>

  <!-- ===== 타이머(공부↔휴식 자동순환) + 게이지 동기화 ===== -->
  <script>
  (function(){
    const modeText  = document.getElementById('modeText');
    const countdown = document.getElementById('countdown');
    const elapsed   = document.getElementById('elapsed');
    const studyMin  = document.getElementById('studyMin');
    const studySec  = document.getElementById('studySec');
    const breakMin  = document.getElementById('breakMin');
    const breakSec  = document.getElementById('breakSec');
    const applyBtn  = document.getElementById('applyTimeBtn');

    const fmt=(s)=>{ s=Math.max(0,s|0); const m=String(Math.floor(s/60)).padStart(2,'0'); const n=String(s%60).padStart(2,'0'); return `${m}:${n}`; };
    const toSec=(t)=>{ const m=String(t||'').match(/(\d{1,2})\s*:\s*(\d{2})/); return m?(+m[1])*60+(+m[2]):0; };
    const getMode=()=>{ const t=modeText.textContent||''; return t.includes('휴식')?'break':(t.includes('공부')?'study':'idle'); };

    /* 게이지 */
    const gaugeWrap=document.getElementById('timeGauge'); const bar=gaugeWrap.querySelector('.bar'); const gTime=document.getElementById('gaugeTime');
    const CIRC=2*Math.PI*50; bar.style.strokeDasharray=String(CIRC); bar.style.strokeDashoffset=String(CIRC);
    let total=1, seed=0;
    function recalcTotal(){
      const m=getMode();
      if(m==='study') total=(+studyMin.value||0)*60+(+studySec.value||0);
      else if(m==='break') total=(+breakMin.value||0)*60+(+breakSec.value||0);
      else total = seed || ((+studyMin.value||0)*60+(+studySec.value||0));
      total=Math.max(1,total);
    }
    function renderGauge(){
      const remain=toSec(countdown.textContent);
      if(remain>0 && !seed){ seed=remain; if(getMode()==='idle') total=seed; }
      if(total<1) recalcTotal();
      const ratio=Math.min(1,Math.max(0,remain/total));
      bar.style.strokeDashoffset=String(CIRC*(1-ratio));
      bar.style.stroke=(ratio<=0.15)?'#ef4444':'url(#gaugeGrad)';
      gTime.textContent=fmt(remain);
    }
    const mo=new MutationObserver(renderGauge);
    mo.observe(countdown,{subtree:true,childList:true,characterData:true});
    mo.observe(modeText,{subtree:true,childList:true,characterData:true});
    [studyMin,studySec,breakMin,breakSec].forEach(el=>el.addEventListener('change',()=>{ seed=0; recalcTotal(); renderGauge(); }));
    recalcTotal(); renderGauge();

    /* === 경과 시간 잠금(정지 중 고정) === */
    const ELAPSED_LOCK = { paused:false, value:'' };
    const elObserver = new MutationObserver(()=>{
      if(ELAPSED_LOCK.paused && elapsed.textContent !== ELAPSED_LOCK.value){
        elapsed.textContent = ELAPSED_LOCK.value;
      }
    });
    elObserver.observe(elapsed,{subtree:true, childList:true, characterData:true});

    /* ===== 타이머 폴백 (RAF 기반) ===== */
    const TIMER={
      running:false, paused:false, fallback:false, raf:0, phase:'study', endAt:0, startAt:0, _lastRemain:-1,
      _totalStudy(){ return Math.max(1,(+studyMin.value||0)*60+(+studySec.value||0)); },
      _totalBreak(){ return Math.max(1,(+breakMin.value||0)*60+(+breakSec.value||0)); },
      _readRemain(){ return toSec(countdown.textContent); },
      _writeRemain(s){ countdown.textContent=`남은 시간: ${fmt(s)}`; },
      _writeElapsed(ms){
        if(ELAPSED_LOCK.paused) return;
        const sec=Math.max(0, Math.floor(ms/1000));
        const h=String(Math.floor(sec/3600)).padStart(2,'0');
        const m=String(Math.floor((sec%3600)/60)).padStart(2,'0');
        const s=String(sec%60).padStart(2,'0');
        elapsed.textContent=`경과 시간: ${h}:${m}:${s}`;
      },
      _setMode(phase){
        if(phase==='study'){ modeText.textContent='모드: 공부'; modeText.classList.remove('mode-break','mode-idle'); modeText.classList.add('mode-study'); }
        else{ modeText.textContent='모드: 휴식'; modeText.classList.remove('mode-study','mode-idle'); modeText.classList.add('mode-break'); }
      },
      _startPhase(phase, fromRemain){
        this.phase=phase; this._setMode(phase);
        const tot=(phase==='study')?this._totalStudy():this._totalBreak();
        const startFrom=(fromRemain>0 && fromRemain<=tot)?fromRemain:tot;
        this.startAt=Date.now();
        /* +999ms로 3,2,1 정확히 보이게 */
        this.endAt=Date.now()+startFrom*1000+999;
        this._lastRemain=-1;
        this._writeRemain(startFrom);
        document.getElementById('startSound')?.play?.().catch(()=>{});
      },
      _rafTick(){
        if(!this.running) return;
        const now = Date.now();
        /* floor((diff)/1000)로 3→2→1 유지 */
        const remain=Math.max(0, Math.floor((this.endAt - now)/1000));
        if(remain!==this._lastRemain){
          this._writeRemain(remain);
          this._lastRemain=remain;
        }
        if(!this.paused) this._writeElapsed(now-this.startAt);

        if(!this.paused && remain<=0){
          document.getElementById('endSound')?.play?.().catch(()=>{});
          this._startPhase(this.phase==='study'?'break':'study');
        }
        this.raf = requestAnimationFrame(()=>this._rafTick());
      },
      start(){
        const before=this._readRemain();
        setTimeout(()=>{
          const after=this._readRemain();
          this.fallback = !((after!==before) && (before>0 || after>0));
          this.running=true; this.paused=false;
          ELAPSED_LOCK.paused=false; ELAPSED_LOCK.value='';
          if(this.fallback){
            const currentMode = (getMode()==='idle')?'study':getMode();
            this._startPhase(currentMode, this._readRemain());
            cancelAnimationFrame(this.raf); this._rafTick();
          }
          updateApplyBtn();
        }, 300);
      },
      pause(){
        if(!this.running || this.paused) return;
        this.paused=true;
        ELAPSED_LOCK.paused=true; ELAPSED_LOCK.value=elapsed.textContent;
        updateApplyBtn();
      },
      resume(){
        if(!this.running || !this.paused) return;
        const tot=(this.phase==='study')?this._totalStudy():this._totalBreak();
        const remain=this._readRemain();
        this.startAt=Date.now() - (tot-remain)*1000;
        this.endAt=Date.now() + remain*1000 + 999;
        this.paused=false;
        ELAPSED_LOCK.paused=false; ELAPSED_LOCK.value='';
        updateApplyBtn();
      },
      stopAll(){ /* 완전 정지(사용 안 함, 필요시용) */
        this.running=false; this.paused=false;
        cancelAnimationFrame(this.raf); this.raf=0;
        updateApplyBtn();
      },
      resetFromCountdown(){
        if(!this.running || !this.fallback) return;
        const r=this._readRemain(); if(r>0) this.endAt=Date.now()+r*1000+999;
      }
    };

    /* 시간 적용 */
    function applyTime(e){
      if(applyBtn.disabled){ e?.preventDefault?.(); return; }
      const payload={ study:{min:+(studyMin.value||0), sec:+(studySec.value||0)}, rest:{min:+(breakMin.value||0), sec:+(breakSec.value||0)} };
      let used = (typeof window.callOne==='function') ? window.callOne(['applyTime','setTimer','updateTime'], payload) : null;
      if(!used){
        const tryFns=(names)=>{ for(const n of names){ const f=typeof window[n]==='function'&&window[n]; if(f){ try{ f(payload);}catch(e){} return true; } } return false; };
        used = tryFns(['applyTime','setTimer','updateTime']);
      }
      if(!used){
        const cur=getMode();
        const sec=(cur==='break') ? payload.rest.min*60+payload.rest.sec : payload.study.min*60+payload.study.sec;
        countdown.textContent=`남은 시간: ${fmt(sec)}`;
      }
      seed=0; recalcTotal(); renderGauge();
      if(TIMER.running && !TIMER.paused) TIMER.resetFromCountdown();

      if(!TIMER.running || TIMER.paused){
        ELAPSED_LOCK.paused=true;
        ELAPSED_LOCK.value=elapsed.textContent;
      }

      window.dispatchEvent(new CustomEvent('app:applyTime',{detail:{used,payload}}));
    }
    applyBtn.addEventListener('click', applyTime);

    /* 입력창에서 키홀드로 타이머 렌더 방해되는 것 방지(실행 중엔 입력 차단) */
    document.addEventListener('keydown', (e)=>{
      if(!(TIMER.running && !TIMER.paused)) return;
      if(e.target===studyMin || e.target===studySec || e.target===breakMin || e.target===breakSec){
        e.preventDefault();
      }
    });

    /* 버튼: 시작/정지(토글 재개) */
    const startBtn=document.getElementById('startBtn'), stopBtn=document.getElementById('stopBtn');
    function updateApplyBtn(){ applyBtn.disabled = (TIMER.running && !TIMER.paused); }
    startBtn.addEventListener('click', ()=>{
      let used = (typeof window.callOne==='function') ? window.callOne(['startRealtime','startRealTime','startAnalysis','start','startDetection']) : null;
      if(!used){ for(const n of ['startRealtime','startRealTime','startAnalysis','start','startDetection']){ const f=typeof window[n]==='function'&&window[n]; if(f){ try{ f(); }catch(e){} used=n; break; } } }
      stopBtn.disabled=false; stopBtn.textContent='정지';
      window.dispatchEvent(new CustomEvent('app:start',{detail:{used}}));
      TIMER.start(); updateApplyBtn();
    });
    stopBtn.addEventListener('click', ()=>{
      if(!TIMER.running){ return; }
      if(!TIMER.paused){
        let used = (typeof window.callOne==='function') ? window.callOne(['stopRealtime','stopAnalysis','stop','stopDetection']) : null;
        if(!used){ for(const n of ['stopRealtime','stopAnalysis','stop','stopDetection']){ const f=typeof window[n]==='function'&&window[n]; if(f){ try{ f(); }catch(e){} used=n; break; } } }
        window.dispatchEvent(new CustomEvent('app:stop',{detail:{used}}));
        TIMER.pause(); stopBtn.textContent='재개';
      }else{
        TIMER.resume(); stopBtn.textContent='정지';
        window.dispatchEvent(new CustomEvent('app:resume',{detail:{phase:TIMER.phase}}));
      }
      updateApplyBtn();
    });
  })();
  </script>

  <!-- ===== 집중력 분석(눈 60% + 자세 40%, 개인 보정) ===== -->
  <script>
  (function(){
    const videoEl=document.getElementById('video');
    const scoreEl=document.getElementById('score');
    const maxEl=document.getElementById('maxScore');

    let holistic, running=false, sending=false, rafId=0;
    let baselineEar=null, smooth=0, best=0, lastPosture=1, peakStreak=0;

    const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
    const ema=(p,n,a=0.25)=>(p==null?n:(p+(n-p)*a));
    const dist=(a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
    function torsoAngleDeg(shoulderMid, hipMid){
      const vx=shoulderMid.x-hipMid.x, vy=shoulderMid.y-hipMid.y;
      const len=Math.hypot(vx,vy)||1e-6; const cos=clamp((-vy)/len,-1,1);
      return Math.acos(cos)*180/Math.PI;
    }
    function getHolisticCtor(){ return (window.holistic && window.holistic.Holistic) || window.Holistic; }
    async function ensureHolistic(){
      if(holistic) return;
      const Ctor=getHolisticCtor(); if(!Ctor){ console.error('Holistic 로드 실패'); return; }
      holistic=new Ctor({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5/${f}`});
      holistic.setOptions({ modelComplexity:1, refineFaceLandmarks:true, smoothLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });
      holistic.onResults(onResults);
    }
    function onResults(res){
      const face=res.faceLandmarks, pose=res.poseLandmarks;

      /* 눈 60% */
      let eyeScore=0.08;
      let ear=0.0;
      if(face && face.length>=468){
        const L_TOP=face[159], L_BOT=face[145], L_OUT=face[33],  L_IN=face[133];
        const R_TOP=face[386], R_BOT=face[374], R_OUT=face[362], R_IN=face[263];
        const left  = dist(L_TOP,L_BOT)/(dist(L_OUT,L_IN)+1e-6);
        const right = dist(R_TOP,R_BOT)/(dist(R_OUT,R_IN)+1e-6);
        ear=(left+right)/2;

        const postureOk=lastPosture>=0.8;
        const notBlink = ear>0.18;
        /* 개인 보정: 더 천천히, 정상 범위에서만 */
        if(postureOk && notBlink && ear>0.20 && ear<0.40){
          baselineEar=ema(baselineEar, ear, 0.01);
        }
        const base=baselineEar || ear;
        const r=clamp(ear/(base+1e-6), 0, 1.4);
        const low=0.70, high=1.05; /* 더 보수적으로 */
        eyeScore=clamp((r-low)/(high-low), 0, 1);
      }

      /* 자세 40% */
      let posture=0.3;
      if(pose && pose.length>=25){
        const lS=pose[11], rS=pose[12], lH=pose[23], rH=pose[24];
        if(lS&&rS&&lH&&rH){
          const shoulderMid={x:(lS.x+rS.x)/2, y:(lS.y+rS.y)/2};
          const hipMid     ={x:(lH.x+rH.x)/2, y:(lH.y+rH.y)/2};
          const ang=torsoAngleDeg(shoulderMid, hipMid);
          const a0=8, a1=30; /* 살짝 강화 */
          posture=clamp(1 - (ang-a0)/(a1-a0), 0, 1);
        }
      }
      lastPosture=posture;

      /* 100% 난이도 상향: 소프트 캡 + 연속 우수 상태만 해제 */
      const goodNow = face && ear>0 && (eyeScore>0.95) && (posture>0.95);
      peakStreak = goodNow ? Math.min(90, peakStreak+1) : Math.max(0, peakStreak-1);
      const softCap = (peakStreak>=45) ? 1.0 : 0.95; // ~1.5초 이상 유지 시 100% 허용

      let c=0.6*eyeScore + 0.4*posture;
      if(!face) c*=0.5;
      c = Math.min(c, softCap);

      smooth=ema(smooth,c,0.35);
      const s=Math.round(clamp(smooth,0,1)*100);
      if(maxEl){ best=Math.max(best,s); maxEl.textContent=`최고 집중도: ${best}%`; }
    }
    async function loop(){
      if(!running || !holistic) return;
      if(!sending){ try{ sending=true; await holistic.send({image:videoEl}); }catch(e){ console.error(e); } finally{ sending=false; } }
      rafId=requestAnimationFrame(loop);
    }
    async function start(){ if(running) return; await ensureHolistic(); baselineEar=null; smooth=0; peakStreak=0; running=true; cancelAnimationFrame(rafId); loop(); }
    function stop(){ running=false; cancelAnimationFrame(rafId); }
    window.startRealtime  = window.startRealtime  || start;
    window.startRealTime  = window.startRealTime  || start;
    window.startAnalysis  = window.startAnalysis  || start;
    window.start          = window.start          || start;
    window.startDetection = window.startDetection || start;
    window.stopRealtime   = window.stopRealtime   || stop;
    window.stopAnalysis   = window.stopAnalysis   || stop;
    window.stop           = window.stop           || stop;
    window.stopDetection  = window.stopDetection  || stop;
  })();
  </script>
</body>
</html>
<!-- http://127.0.0.1:5000 -->
<!-- https://focus-web.onrender.com -->